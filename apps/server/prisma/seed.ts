import { existsSync } from "node:fs";
import { readFile, readdir, writeFile } from "node:fs/promises";
import { extname, resolve } from "node:path";

import { isEqual } from "lodash";

import { parse, stringify } from "@iarna/toml";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();
const seedsDir = resolve(__dirname, "seeds");
const seedSaveFile = resolve(__dirname, "migrations/seed_lock.toml");

interface Seed {
  table: string;
  data: Record<string, unknown>[];
  upsertBy?: string[];
}

interface SeedSave {
  [seedName: string]: {
    isSucceed: boolean;
    lastSavedSeed: Seed;
    lastSavedAt: Date;
  };
}

(async () => {
  const seedSave = existsSync(seedSaveFile)
    ? (parse(await readFile(seedSaveFile, "utf-8")) as unknown as SeedSave)
    : {};
  const seeds = await readdir(seedsDir);

  for (const seed of seeds.reverse()) {
    const basename = seed.replace(extname(seed), "");

    const seedSaveDatum = seedSave[basename] || ({} as SeedSave[string]);
    const seedPath = resolve(seedsDir, seed);
    const { default: seedData } = (await import(seedPath)) as { default: Seed };
    if (!seedData) throw new Error(`No seed data found in ${seedPath}`);

    if (seedSaveDatum.isSucceed) {
      console.log(`\x1b[2mSeed "${seed}" seeded successfully before.\x1b[0m`);
      if (!isEqual(seedSaveDatum.lastSavedSeed, seedData)) {
        throw new Error(
          `Seed "${seed}" has been changed since last seeding. Please revert changes and try again.`
        );
      }
      continue;
    }
    console.log(`Seeding "${seed}".`);

    const { table, data, upsertBy = [] } = seedData;
    const tableNameInPrisma = table[0].toLowerCase() + table.slice(1);
    let isSucceed = false;

    await prisma.$transaction(async prisma => {
      for (const datum of data) {
        if (upsertBy.length) {
          try {
            const where = Object.fromEntries(upsertBy.map(key => [key, datum[key]]));
            await prisma[tableNameInPrisma].upsert({ where, update: {}, create: datum });
            isSucceed = true;
          } catch (e) {
            if (
              (e.message as string).match(
                /Argument `\w+` of type \w+ needs at least one of `\w+` arguments\. Available options are marked with \?/
              )
            ) {
              const message = `Upsert failed: Field${
                upsertBy.length > 1 ? "s" : ""
              } [${upsertBy.join(", ")}] are should be unique in model "${table}"`;
              throw new Error(message);
            }
          }
        } else {
          await prisma[tableNameInPrisma].create({ data: datum });
        }
      }
    });

    seedSaveDatum.isSucceed = isSucceed;
    seedSaveDatum.lastSavedSeed = seedData;
    seedSaveDatum.lastSavedAt = new Date();
    seedSave[basename] = seedSaveDatum;
  }

  await writeFile(
    seedSaveFile,
    [
      "# Please do not edit this file manually",
      "# It should be added in your version-control system (i.e. Git)",
      stringify(seedSave as any)
    ].join("\n")
  );
})()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
